/*
import openai from '../openai/openaiClient';



const response = await openai.chat.completions.create({
    model: "gpt-4o",
    messages: [
        {
            "role": "system",
            "content": [
                {
                    "text": "When I ask you to create reusable nice-working for React, you will ensure you follow these exact guidelines:\n\n1. Always provide all code using .tsx (TypeScript)\n2. Ensure proper usage of Mantine props for this element. \n3. When creating reusable nice-working for this application, it's important that styling elements and things related to spacing, colors and fonts are not editable, except in specific situations so you will not make these into props.\n4. These elements must be extremely dynamic so other than the parts we don't want changed, we want them to be used with as many \"OPTIONAL\" props as possible to ensure full control.\n5. The nice-working will always be placed into a directory called \"ui\" and then a subdirectory with a name that matches the component. Within this directory, we will house variations of this element that will all use the core element, but will have customizations that allow them to be used consistently in groups or other ways as reusable groups or variations.\n6. Always provide the full folder structure and filenames in your responses.\n7. Include the path to the file as a comment in the first line of code.\n8. Never add any other comments within the code as the IDE causes errors. No comments in code. Make all comments in the response and only when necessary.\n\n\nHere is an example response:\nNew Directory: ui/checkbox\nNew File: PillsInput.tsx\n\n// ui/pills/PillsInput.tsx\nimport { PillsInput, Pill } from '@mantine/core'; import { useState, useRef } from 'react'; interface CustomPillsInputProps<T> { initialPills: T[]; placeholder: string; label: string; description: string; renderPillContent: (item: T) => React.ReactNode; onPillsChange?: (pills: T[]) => void; } function CustomPillsInput<T>({ initialPills, placeholder, label, description, renderPillContent, onPillsChange }: CustomPillsInputProps<T>) { const [pills, setPills] = useState<T[]>(initialPills); const inputRef = useRef<HTMLInputElement>(null); const handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>) => { if (event.key === 'Enter') { const newPillContent = (event.target as HTMLInputElement).value.trim(); if (newPillContent) { const updatedPills = [...pills, newPillContent as unknown as T]; setPills(updatedPills); if (onPillsChange) { onPillsChange(updatedPills); } (event.target as HTMLInputElement).value = ''; event.preventDefault(); } } else if (event.key === 'Backspace' && (event.target as HTMLInputElement).value === '') { // Check if input is empty and backspace is pressed if (pills.length > 0) { removePill(pills.length - 1); } } }; const removePill = (index: number) => { const updatedPills = pills.filter((_, i) => i !== index); setPills(updatedPills); if (onPillsChange) { onPillsChange(updatedPills); } }; return ( <PillsInput size=\"md\" label={label} description={description} > <Pill.Group> {pills.map((pill, index) => ( <Pill key={index} onRemove={() => removePill(index)} withRemoveButton > {renderPillContent(pill)} </Pill> ))} <PillsInput.Field placeholder={placeholder} onKeyDown={handleKeyDown} ref={inputRef} /> </Pill.Group> </PillsInput> ); } export default CustomPillsInput;\n\nImpors are from from '@mantine/core' and props do not need to be imported as they are part of the item.",
                    "type": "text"
                }
            ]
        },
        {
            "role": "user",
            "content": [
                {
                    "text": "Create this as a reusable component:\nimport { Checkbox } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Checkbox\n      defaultChecked\n      label=\"I agree to sell my privacy\"\n    />\n  );\n}\n\nimport { MantineProvider, createTheme, Checkbox } from '@mantine/core';\n\nconst theme = createTheme({\n  cursorType: 'pointer',\n});\n\nfunction Demo() {\n  return (\n    <>\n      <Checkbox label=\"Default cursor\" />\n\n      <MantineProvider theme={theme}>\n        <Checkbox label=\"Pointer cursor\" mt=\"md\" />\n      </MantineProvider>\n    </>\n  );\n}\n\nIn addition to the features and props you feel are good to have, include these options as well:\n- Tooltips\n- Pointer Cursor\n\n\nAll Available Props:\nCheckbox component props\nNameTypeDescriptionautoContrastbooleanDetermines whether icon color with filled variant should depend on background-color. If luminosity of the color prop is less than theme.luminosityThreshold, then theme.white will be used for text color, otherwise theme.black. Overrides theme.autoContrast.colorMantineColorKey of theme.colors or any valid CSS color to set input background color in checked state, theme.primaryColor by defaultdescriptionReact.ReactNodeDescription displayed below the labelerrorReact.ReactNodeError message displayed below the labeliconFC<{ indeterminate: boolean; className: string; }> | undefinedIcon displayed when checkbox is in checked or indeterminate stateiconColorMantineColorKey of theme.colors or any valid CSS color to set icon color, by default value depends on theme.autoContrastidstringId used to connect input with the label. If not set, unique id is generated instead.indeterminatebooleanIndeterminate state of the checkbox. If set, checked prop is ignored.labelReact.ReactNodeContent of the label associated with the checkboxlabelPosition\"left\" | \"right\"Position of the label relative to the input, 'right' by defaultradiusMantineRadius | numberKey of theme.radius or any valid CSS value to set border-radius, theme.defaultRadius by defaultrootRefForwardedRef<HTMLDivElement>Assigns ref of the root elementsizeMantineSize | (string & {})Controls size of the component, 'sm' by defaultwrapperPropsRecord<string, any>Props passed down to the root element\nCheckbox.Group component props\nNameTypeDescriptionchildren *React.ReactNodeCheckbox nice-working and any other elementsdefaultValuestring[]Default value for uncontrolled componentdescriptionReact.ReactNodeContents of Input.Description component. If not set, description is not rendered.descriptionPropsRecord<string, any>Props passed down to the Input.Description componenterrorReact.ReactNodeContents of Input.Error component. If not set, error is not rendered.errorPropsRecord<string, any>Props passed down to the Input.Error componentidstringStatic id used as base to generate aria- attributes, by default generates random idinputContainer((children: ReactNode) => ReactNode)Input container component, React.Fragment by defaultinputWrapperOrder(\"input\" | \"label\" | \"description\" | \"error\")[]Controls order of the elements, ['label', 'description', 'input', 'error'] by defaultlabelReact.ReactNodeContents of Input.Label component. If not set, label is not rendered.labelElement\"div\" | \"label\"Input.Label root element, 'label' by defaultlabelPropsRecord<string, any>Props passed down to the Input.Label componentonChange((value: string[]) => void)Called with an array of selected checkboxes values when value changesreadOnlybooleanIf set, value cannot be changedrequiredbooleanAdds required attribute to the input and a red asterisk on the right side of label, false by defaultsizeMantineSize | (string & {})Controls size of the Input.Wrapper, 'sm' by defaultvaluestring[]Controlled component valuewithAsteriskbooleanDetermines whether the required asterisk should be displayed. Overrides required prop. Does not add required attribute to the input. false by defaultwrapperPropsRecord<string, any>Props passed down to the root element (Input.Wrapper component)\n\nProvide the full and complete code for this reusable element, without any additional comments in the code. Provide only one version and no sample usage is necessary.",
                    "type": "text"
                }
            ]
        },
        {
            "role": "assistant",
            "content": [
                {
                    "text": "New Directory: ui/checkbox\nNew File: CustomCheckbox.tsx\n\n```tsx\n// ui/checkbox/CustomCheckbox.tsx\nimport { Checkbox, CheckboxProps, Tooltip, MantineProvider, createTheme } from '@mantine/core';\n\ninterface CustomCheckboxProps extends CheckboxProps {\n  tooltip?: string;\n  usePointerCursor?: boolean;\n}\n\nconst pointerCursorTheme = createTheme({\n  cursorType: 'pointer',\n});\n\nfunction CustomCheckbox({ tooltip, usePointerCursor, ...props }: CustomCheckboxProps) {\n  const checkboxElement = <Checkbox {...props} />;\n  const checkboxWithTooltip = tooltip ? <Tooltip label={tooltip}>{checkboxElement}</Tooltip> : checkboxElement;\n\n  return usePointerCursor ? (\n    <MantineProvider theme={pointerCursorTheme}>{checkboxWithTooltip}</MantineProvider>\n  ) : (\n    checkboxWithTooltip\n  );\n}\n\nexport default CustomCheckbox;\n```",
                    "type": "text"
                }
            ]
        }
    ],
    temperature: 0.44,
    max_tokens: 1528,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
});*/
